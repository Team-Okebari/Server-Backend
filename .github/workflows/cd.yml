name: Artbite Backend CD

on:
  push:
    branches: [ "main" ]

jobs:
  deploy:
    runs-on: self-hosted
    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. EC2에 필요한 파일 전송
      - name: Copy deployment files to EC2
        uses: appleboy/scp-action@v0.1.5
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          # 필요한 모든 파일 및 디렉토리 (prometheus/ 디렉토리도 포함)
          source: "docker-compose.yml,Dockerfile,build.gradle,settings.gradle,gradlew,gradle/,src/,infra/,prometheus/"
          target: ~/backend/
          overwrite: true

      # 3. EC2에서 서비스 배포 및 시작
      - name: Deploy and start services on EC2
        uses: appleboy/ssh-action@v0.1.6
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          timeout: 1800s   # <- 추가: SSH 명령 타임아웃 연장
          script: |
            set -euo pipefail # Add this for robust script execution

            DEPLOY_DIR=~/backend
            cd $DEPLOY_DIR
            
            # === .env 파일 생성 시작 ===
            echo "Creating .env file from GitHub Secrets..."
            cat << EOF > .env
            # Auto-generated by GitHub Actions
            CORS_URL=${{ secrets.CORS_URL }}
            SPRING_DATASOURCE_URL=${{ secrets.SPRING_DATASOURCE_URL }}
            SPRING_DATASOURCE_USERNAME=${{ secrets.SPRING_DATASOURCE_USERNAME }}
            SPRING_DATASOURCE_PASSWORD=${{ secrets.SPRING_DATASOURCE_PASSWORD }}
            SPRING_DATASOURCE_DRIVER_CLASS_NAME=${{ secrets.SPRING_DATASOURCE_DRIVER_CLASS_NAME }}
            SPRING_JPA_DATABASE_PLATFORM=${{ secrets.SPRING_JPA_DATABASE_PLATFORM }}
            SPRING_DATA_REDIS_HOST=${{ secrets.SPRING_DATA_REDIS_HOST }}
            SPRING_DATA_REDIS_PORT=${{ secrets.SPRING_DATA_REDIS_PORT }}
            ELASTICSEARCH_VERSION=${{ secrets.ELASTICSEARCH_VERSION }}
            ELASTICSEARCH_PORT=${{ secrets.ELASTICSEARCH_PORT }}
            ELASTICSEARCH_HOST=${{ secrets.ELASTICSEARCH_HOST }}
            LOGSTASH_BEATS_PORT=${{ secrets.LOGSTASH_BEATS_PORT }}
            LOGSTASH_HTTP_PORT=${{ secrets.LOGSTASH_HTTP_PORT }}
            LOGSTASH_VERSION=${{ secrets.LOGSTASH_VERSION }}
            KIBANA_VERSION=${{ secrets.KIBANA_VERSION }}
            KIBANA_PORT=${{ secrets.KIBANA_PORT }}
            JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY }}
            JWT_ACCESS_TOKEN_EXPIRE_TIME=${{ secrets.JWT_ACCESS_TOKEN_EXPIRE_TIME }}
            JWT_REFRESH_TOKEN_EXPIRE_TIME=${{ secrets.JWT_REFRESH_TOKEN_EXPIRE_TIME }}
            SPRING_PROFILES_ACTIVE=${{ secrets.SPRING_PROFILES_ACTIVE }}
            TOSS_PAYMENTS_TEST_CLIENT_API_KEY=${{ secrets.TOSS_PAYMENTS_TEST_CLIENT_API_KEY }}
            TOSS_PAYMENTS_TEST_SECRET_API_KEY=${{ secrets.TOSS_PAYMENTS_TEST_SECRET_API_KEY }}
            TOSS_PAYMENTS_SUCCESS_URL=${{ secrets.TOSS_PAYMENTS_SUCCESS_URL }}
            TOSS_PAYMENTS_FAIL_URL=${{ secrets.TOSS_PAYMENTS_FAIL_URL }}
            SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_GOOGLE_CLIENT_ID=${{ secrets.SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_GOOGLE_CLIENT_ID }}
            SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_GOOGLE_CLIENT_SECRET=${{ secrets.SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_GOOGLE_CLIENT_SECRET }}
            SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_KAKAO_CLIENT_ID=${{ secrets.SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_KAKAO_CLIENT_ID }}
            SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_KAKAO_CLIENT_SECRET=${{ secrets.SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_KAKAO_CLIENT_SECRET }}
            SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_NAVER_CLIENT_ID=${{ secrets.SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_NAVER_CLIENT_ID }}
            SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_NAVER_CLIENT_SECRET=${{ secrets.SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_NAVER_CLIENT_SECRET }}
            OAUTH2_REDIRECT_URI_SUCCESS=${{ secrets.OAUTH2_REDIRECT_URI_SUCCESS }}
            OAUTH2_LOGOUT_REDIRECT_URI_KAKAO=${{ secrets.OAUTH2_LOGOUT_REDIRECT_URI_KAKAO }}
            DOCKER_IMAGE=artbite-backend:${{ github.sha }}
            EOF
            # === .env 파일 생성 끝 ===

            # Build Docker image locally
            echo "Building Docker image: artbite-backend:${{ github.sha }}"
            docker build --progress=plain -t artbite-backend:${{ github.sha }} -f ./Dockerfile .
            
            echo "Stopping all services..."
            chmod +x ./infra/scripts/stop.sh
            sudo ./infra/scripts/stop.sh
            
            echo "Starting services with start.sh..."
            chmod +x ./infra/scripts/start.sh
            sudo ./infra/scripts/start.sh

            # 디버그 출력: 컨테이너 목록과 관련 로그
            echo "Listing all containers:"
            docker ps -a

            APP_CID=$(docker ps -q --filter "ancestor=artbite-backend:${{ github.sha }}" || true)
            if [ -n "$APP_CID" ]; then
              echo "App container id(s): $APP_CID"
              docker logs $APP_CID --tail 200 || true
            else
              echo "No running container from image artbite-backend:${{ github.sha }}"
            fi
            
            echo "Waiting for application to be healthy..."
            HEALTH_CHECK_URL="http://localhost:8080/actuator/health"
            MAX_RETRIES=10
            RETRY_INTERVAL=10
            
            for i in $(seq 1 $MAX_RETRIES); do
              HEALTH_STATUS=$(curl -s -o /dev/null -w "%\{http_code}" "$HEALTH_CHECK_URL" || echo "000")
              if [ "$HEALTH_STATUS" -eq 200 ]; then
                echo "Application is healthy!"
                break
              else
                echo "Application not healthy yet (status: $HEALTH_STATUS). Retrying in $RETRY_INTERVAL seconds..."
                sleep $RETRY_INTERVAL
              fi

              if [ "$i" -eq "$MAX_RETRIES" ]; then
                echo "Application did not become healthy after $MAX_RETRIES retries. Deployment failed."
                # 컨테이너 로그 추가 출력(디버깅)
                docker ps -a || true
                if [ -n "$APP_CID" ]; then docker logs $APP_CID || true; fi
                exit 1
              fi
            done
            
            echo "Cleaning up unused Docker images..."
            docker image prune -af
            
            echo "Deployment completed!"
